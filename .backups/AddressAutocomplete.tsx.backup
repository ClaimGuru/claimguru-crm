import React, { useEffect, useRef, useState } from 'react'\nimport { Loader } from '@googlemaps/js-api-loader'\nimport { Input } from './Input'\nimport { MapPin, AlertCircle, CheckCircle } from 'lucide-react'\n\ninterface AddressData {\n  address: string\n  city: string\n  state: string\n  zipCode: string\n  country: string\n  formattedAddress: string\n  placeId: string\n  coordinates?: {\n    lat: number\n    lng: number\n  }\n}\n\ninterface ValidationResult {\n  isValid: boolean\n  inCoveredTerritory: boolean\n  territoryMessage: string\n  riskLevel?: 'low' | 'medium' | 'high'\n  riskFactors?: string[]\n}\n\ninterface AddressAutocompleteProps {\n  label?: string\n  placeholder?: string\n  value?: string\n  onChange?: (addressData: AddressData) => void\n  onValidation?: (validation: ValidationResult) => void\n  required?: boolean\n  coveredTerritories?: string[] // States or regions covered by policy\n  validateTerritory?: boolean\n  className?: string\n  disabled?: boolean\n}\n\nexport const AddressAutocomplete: React.FC<AddressAutocompleteProps> = ({\n  label,\n  placeholder = \"Enter address...\",\n  value = '',\n  onChange,\n  onValidation,\n  required = false,\n  coveredTerritories = ['TX', 'FL', 'CA', 'NY'], // Default covered states\n  validateTerritory = false,\n  className = '',\n  disabled = false\n}) => {\n  const inputRef = useRef<HTMLInputElement>(null)\n  const autocompleteRef = useRef<google.maps.places.Autocomplete | null>(null)\n  const [isLoaded, setIsLoaded] = useState(false)\n  const [inputValue, setInputValue] = useState(value)\n  const [validation, setValidation] = useState<ValidationResult | null>(null)\n  const [isValidating, setIsValidating] = useState(false)\n\n  // Initialize Google Places API\n  useEffect(() => {\n    const initializeGooglePlaces = async () => {\n      try {\n        const loader = new Loader({\n          apiKey: process.env.REACT_APP_GOOGLE_MAPS_API_KEY || 'demo-key',\n          version: 'weekly',\n          libraries: ['places']\n        })\n\n        await loader.load()\n        setIsLoaded(true)\n      } catch (error) {\n        console.error('Failed to load Google Places API:', error)\n        // Fallback to basic input without autocomplete\n        setIsLoaded(false)\n      }\n    }\n\n    initializeGooglePlaces()\n  }, [])\n\n  // Setup autocomplete when Google Places is loaded\n  useEffect(() => {\n    if (!isLoaded || !inputRef.current || autocompleteRef.current) return\n\n    try {\n      const autocomplete = new google.maps.places.Autocomplete(inputRef.current, {\n        types: ['address'],\n        componentRestrictions: { country: 'us' }, // Restrict to US addresses\n        fields: ['address_components', 'formatted_address', 'geometry', 'place_id']\n      })\n\n      autocomplete.addListener('place_changed', () => {\n        const place = autocomplete.getPlace()\n        if (!place.address_components) return\n\n        const addressData = parseGooglePlace(place)\n        setInputValue(addressData.formattedAddress)\n        \n        if (onChange) {\n          onChange(addressData)\n        }\n\n        if (validateTerritory) {\n          validateAddressTerritory(addressData)\n        }\n      })\n\n      autocompleteRef.current = autocomplete\n    } catch (error) {\n      console.error('Failed to initialize autocomplete:', error)\n    }\n  }, [isLoaded, onChange, validateTerritory])\n\n  // Parse Google Place object into AddressData\n  const parseGooglePlace = (place: google.maps.places.PlaceResult): AddressData => {\n    const components = place.address_components || []\n    const addressData: AddressData = {\n      address: '',\n      city: '',\n      state: '',\n      zipCode: '',\n      country: '',\n      formattedAddress: place.formatted_address || '',\n      placeId: place.place_id || '',\n      coordinates: place.geometry?.location ? {\n        lat: place.geometry.location.lat(),\n        lng: place.geometry.location.lng()\n      } : undefined\n    }\n\n    components.forEach(component => {\n      const types = component.types\n      const value = component.long_name\n      const shortValue = component.short_name\n\n      if (types.includes('street_number')) {\n        addressData.address = value\n      } else if (types.includes('route')) {\n        addressData.address = addressData.address ? `${addressData.address} ${value}` : value\n      } else if (types.includes('locality')) {\n        addressData.city = value\n      } else if (types.includes('administrative_area_level_1')) {\n        addressData.state = shortValue\n      } else if (types.includes('postal_code')) {\n        addressData.zipCode = value\n      } else if (types.includes('country')) {\n        addressData.country = shortValue\n      }\n    })\n\n    return addressData\n  }\n\n  // Validate address territory and assess risk\n  const validateAddressTerritory = async (addressData: AddressData) => {\n    setIsValidating(true)\n    \n    try {\n      // Simulate AI validation with geographic risk assessment\n      await new Promise(resolve => setTimeout(resolve, 1000))\n      \n      const isInTerritory = coveredTerritories.includes(addressData.state)\n      const validation: ValidationResult = {\n        isValid: !!addressData.address && !!addressData.city && !!addressData.state,\n        inCoveredTerritory: isInTerritory,\n        territoryMessage: isInTerritory \n          ? `Property is in covered territory (${addressData.state})`\n          : `Property is outside covered territories. Current coverage: ${coveredTerritories.join(', ')}`,\n        riskLevel: calculateRiskLevel(addressData),\n        riskFactors: generateRiskFactors(addressData)\n      }\n      \n      setValidation(validation)\n      \n      if (onValidation) {\n        onValidation(validation)\n      }\n    } catch (error) {\n      console.error('Address validation failed:', error)\n    } finally {\n      setIsValidating(false)\n    }\n  }\n\n  // Calculate risk level based on location\n  const calculateRiskLevel = (addressData: AddressData): 'low' | 'medium' | 'high' => {\n    // Simulate risk calculation based on state and other factors\n    const highRiskStates = ['FL', 'LA', 'TX'] // Hurricane/flood prone\n    const mediumRiskStates = ['CA', 'OK', 'KS'] // Earthquake/tornado prone\n    \n    if (highRiskStates.includes(addressData.state)) {\n      return 'high'\n    } else if (mediumRiskStates.includes(addressData.state)) {\n      return 'medium'\n    } else {\n      return 'low'\n    }\n  }\n\n  // Generate risk factors based on location\n  const generateRiskFactors = (addressData: AddressData): string[] => {\n    const factors = []\n    \n    switch (addressData.state) {\n      case 'FL':\n        factors.push('Hurricane risk zone', 'Flood prone area', 'High humidity (mold risk)')\n        break\n      case 'CA':\n        factors.push('Earthquake risk', 'Wildfire prone area', 'High property values')\n        break\n      case 'TX':\n        factors.push('Tornado risk', 'Hail damage area', 'Extreme weather events')\n        break\n      case 'LA':\n        factors.push('Hurricane risk', 'Flood zone', 'Severe weather')\n        break\n      default:\n        factors.push('Standard risk profile')\n    }\n    \n    return factors\n  }\n\n  // Handle manual input when Google Places is not available\n  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const newValue = e.target.value\n    setInputValue(newValue)\n    \n    // If Google Places is not loaded, simulate basic address parsing\n    if (!isLoaded && onChange && newValue.length > 10) {\n      const addressData: AddressData = {\n        address: newValue,\n        city: '',\n        state: '',\n        zipCode: '',\n        country: 'US',\n        formattedAddress: newValue,\n        placeId: ''\n      }\n      onChange(addressData)\n    }\n  }\n\n  const getValidationIcon = () => {\n    if (isValidating) {\n      return <div className=\"animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600\"></div>\n    }\n    \n    if (!validation) return null\n    \n    if (validation.isValid && validation.inCoveredTerritory) {\n      return <CheckCircle className=\"h-4 w-4 text-green-600\" />\n    } else if (!validation.inCoveredTerritory) {\n      return <AlertCircle className=\"h-4 w-4 text-red-600\" />\n    } else {\n      return <AlertCircle className=\"h-4 w-4 text-yellow-600\" />\n    }\n  }\n\n  const getValidationColor = () => {\n    if (!validation) return ''\n    \n    if (validation.isValid && validation.inCoveredTerritory) {\n      return 'border-green-300 focus:border-green-500 focus:ring-green-200'\n    } else if (!validation.inCoveredTerritory) {\n      return 'border-red-300 focus:border-red-500 focus:ring-red-200'\n    } else {\n      return 'border-yellow-300 focus:border-yellow-500 focus:ring-yellow-200'\n    }\n  }\n\n  return (\n    <div className={`space-y-2 ${className}`}>\n      {/* Address Input */}\n      <div className=\"relative\">\n        <div className=\"relative\">\n          {label && (\n            <label className=\"block text-sm font-medium text-gray-700 mb-1\">\n              {label}{required && <span className=\"text-red-500 ml-1\">*</span>}\n            </label>\n          )}\n          <div className=\"relative\">\n            <MapPin className=\"absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400\" />\n            <input\n              ref={inputRef}\n              type=\"text\"\n              value={inputValue}\n              onChange={handleInputChange}\n              placeholder={placeholder}\n              required={required}\n              disabled={disabled}\n              className={`w-full pl-10 pr-10 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 ${getValidationColor()}`}\n            />\n          </div>\n        </div>\n        \n        {/* Validation Icon */}\n        <div className=\"absolute right-3 top-8 flex items-center\">\n          {getValidationIcon()}\n        </div>\n      </div>\n\n      {/* Google Places Status */}\n      {!isLoaded && (\n        <p className=\"text-xs text-gray-500\">\n          ⚠️ Address autocomplete unavailable. Enter address manually.\n        </p>\n      )}\n\n      {/* Validation Results */}\n      {validation && (\n        <div className={`p-3 rounded-lg text-sm ${\n          validation.isValid && validation.inCoveredTerritory\n            ? 'bg-green-50 border border-green-200'\n            : !validation.inCoveredTerritory\n            ? 'bg-red-50 border border-red-200'\n            : 'bg-yellow-50 border border-yellow-200'\n        }`}>\n          <div className=\"flex items-start space-x-2\">\n            {getValidationIcon()}\n            <div className=\"flex-1\">\n              <p className={`font-medium ${\n                validation.isValid && validation.inCoveredTerritory\n                  ? 'text-green-800'\n                  : !validation.inCoveredTerritory\n                  ? 'text-red-800'\n                  : 'text-yellow-800'\n              }`}>\n                {validation.territoryMessage}\n              </p>\n              \n              {validation.riskLevel && validation.riskFactors && (\n                <div className=\"mt-2\">\n                  <div className=\"flex items-center space-x-2 mb-1\">\n                    <span className={`px-2 py-1 text-xs rounded-full ${\n                      validation.riskLevel === 'high' ? 'bg-red-100 text-red-800' :\n                      validation.riskLevel === 'medium' ? 'bg-yellow-100 text-yellow-800' :\n                      'bg-green-100 text-green-800'\n                    }`}>\n                      {validation.riskLevel.toUpperCase()} RISK\n                    </span>\n                  </div>\n                  <ul className=\"text-xs space-y-1 ml-4\">\n                    {validation.riskFactors.map((factor, index) => (\n                      <li key={index} className=\"flex items-start space-x-1\">\n                        <span className=\"w-1 h-1 bg-current rounded-full mt-1.5 flex-shrink-0\"></span>\n                        <span>{factor}</span>\n                      </li>\n                    ))}\n                  </ul>\n                </div>\n              )}\n            </div>\n          </div>\n        </div>\n      )}\n    </div>\n  )\n}\n