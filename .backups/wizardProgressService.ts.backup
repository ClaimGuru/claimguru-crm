/**
 * WIZARD PROGRESS SERVICE - ClaimGuru
 * 
 * Handles automatic progress saving and task creation for claim wizard
 * Ensures users never lose progress if interrupted
 */

import { supabase } from '../lib/supabase';

export interface WizardProgress {
  id?: string;
  user_id: string;
  organization_id: string;
  wizard_type: 'claim' | 'client' | 'policy';
  current_step: number;
  total_steps: number;
  progress_percentage: number;
  wizard_data: any;
  step_statuses: {
    [stepId: string]: {
      completed: boolean;
      required: boolean;
      validation_errors?: string[];
      completed_at?: string;
    };
  };
  last_saved_at: string;
  last_active_at: string;
  created_at?: string;
  expires_at: string; // Auto-cleanup after 30 days
  reminder_task_id?: string;
}

export interface ProgressTask {
  id?: string;
  user_id: string;
  organization_id: string;
  title: string;
  description: string;
  priority: 'high' | 'medium' | 'low';
  due_date: string;
  status: 'pending' | 'in_progress' | 'completed' | 'cancelled';
  task_type: 'wizard_completion' | 'follow_up' | 'reminder';
  related_entity_type: 'wizard_progress' | 'claim' | 'client';
  related_entity_id: string;
  metadata: any;
  created_at?: string;
}

export class WizardProgressService {
  private static readonly LOCAL_STORAGE_KEY = 'claimguru_wizard_progress';
  private static fallbackMode = false;

  /**
   * Save wizard progress automatically with 406 error handling and local storage fallback
   */
  static async saveProgress(progress: Omit<WizardProgress, 'id' | 'created_at'>): Promise<WizardProgress | null> {
    try {
      console.log('üíæ Saving wizard progress...', {
        step: progress.current_step,
        type: progress.wizard_type,
        progress: progress.progress_percentage,
        fallbackMode: this.fallbackMode
      });

      // If in fallback mode, save to local storage immediately
      if (this.fallbackMode) {
        return this.saveToLocalStorage(progress);
      }

      // Try database save first
      try {
        // Check if progress already exists
        const { data: existingProgress, error: searchError } = await supabase
          .from('wizard_progress')
          .select('*')
          .eq('user_id', progress.user_id)
          .eq('wizard_type', progress.wizard_type)
          .eq('organization_id', progress.organization_id)
          .single();

        // Handle 406 Not Acceptable error specifically
        if (searchError && searchError.message?.includes('406')) {
          console.warn('üîÑ Database RLS issue detected (406), switching to local storage fallback');
          this.fallbackMode = true;
          return this.saveToLocalStorage(progress);
        }

        if (searchError && searchError.code !== 'PGRST116') { // Not found is OK
          console.error('Error checking existing progress:', searchError);
          // Try local storage fallback
          return this.saveToLocalStorage(progress);
        }

        const progressData = {
          ...progress,
          last_saved_at: new Date().toISOString(),
          last_active_at: new Date().toISOString(),
          expires_at: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString() // 30 days
        };

        let savedProgress: WizardProgress;

        if (existingProgress) {
          // Update existing progress
          const { data, error } = await supabase
            .from('wizard_progress')
            .update(progressData)
            .eq('id', existingProgress.id)
            .select()
            .single();

          if (error) {
            // Handle 406 error specifically
            if (error.message?.includes('406')) {
              console.warn('üîÑ Database RLS issue on update (406), switching to local storage fallback');
              this.fallbackMode = true;
              return this.saveToLocalStorage(progress);
            }
            console.error('Error updating wizard progress:', error);
            return this.saveToLocalStorage(progress);
          }
          savedProgress = data;
        } else {
          // Create new progress
          const { data, error } = await supabase
            .from('wizard_progress')
            .insert([progressData])
            .select()
            .single();

          if (error) {
            // Handle 406 error specifically
            if (error.message?.includes('406')) {
              console.warn('üîÑ Database RLS issue on insert (406), switching to local storage fallback');
              this.fallbackMode = true;
              return this.saveToLocalStorage(progress);
            }
            console.error('Error saving wizard progress:', error);
            return this.saveToLocalStorage(progress);
          }
          savedProgress = data;
        }

        // Create or update reminder task if needed (skip if in fallback mode)
        try {
          await this.manageReminderTask(savedProgress);
        } catch (taskError) {
          console.warn('Task creation failed, but progress saved:', taskError);
        }

        console.log('‚úÖ Wizard progress saved successfully to database');
        return savedProgress;

      } catch (dbError) {
        console.warn('Database save failed, using local storage fallback:', dbError);
        return this.saveToLocalStorage(progress);
      }

    } catch (error) {
      console.error('‚ùå Failed to save wizard progress:', error);
      // Final fallback to local storage
      return this.saveToLocalStorage(progress);
    }
  }

  /**
   * Save progress to local storage as fallback
   */
  private static saveToLocalStorage(progress: Omit<WizardProgress, 'id' | 'created_at'>): WizardProgress {
    try {
      const progressData: WizardProgress = {
        ...progress,
        id: `local_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        created_at: new Date().toISOString(),
        last_saved_at: new Date().toISOString(),
        last_active_at: new Date().toISOString(),
        expires_at: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString()
      };

      // Get existing local storage data
      const existingDataStr = localStorage.getItem(this.LOCAL_STORAGE_KEY);
      const existingData: WizardProgress[] = existingDataStr ? JSON.parse(existingDataStr) : [];

      // Remove any existing progress for the same wizard type
      const filteredData = existingData.filter(p => 
        !(p.user_id === progress.user_id && 
          p.organization_id === progress.organization_id && 
          p.wizard_type === progress.wizard_type)
      );

      // Add new progress
      filteredData.push(progressData);

      // Save back to localStorage
      localStorage.setItem(this.LOCAL_STORAGE_KEY, JSON.stringify(filteredData));

      console.log('‚úÖ Wizard progress saved to local storage (fallback mode)');
      return progressData;
    } catch (error) {
      console.error('‚ùå Failed to save to local storage:', error);
      // Return a minimal progress object to keep the wizard functional
      return {
        ...progress,
        id: `temp_${Date.now()}`,
        created_at: new Date().toISOString(),
        last_saved_at: new Date().toISOString(),
        last_active_at: new Date().toISOString(),
        expires_at: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString()
      };
    }
  }

  /**
   * Load progress from local storage
   */
  private static loadFromLocalStorage(userId: string, organizationId: string, wizardType: string): WizardProgress | null {
    try {
      const existingDataStr = localStorage.getItem(this.LOCAL_STORAGE_KEY);
      if (!existingDataStr) return null;

      const existingData: WizardProgress[] = JSON.parse(existingDataStr);
      const progress = existingData.find(p => 
        p.user_id === userId && 
        p.organization_id === organizationId && 
        p.wizard_type === wizardType
      );

      if (progress) {
        // Update last active time
        progress.last_active_at = new Date().toISOString();
        localStorage.setItem(this.LOCAL_STORAGE_KEY, JSON.stringify(existingData));
        console.log('‚úÖ Loaded wizard progress from local storage');
      }

      return progress || null;
    } catch (error) {
      console.error('‚ùå Failed to load from local storage:', error);
      return null;
    }
  }

  /**
   * Load existing wizard progress with fallback support
   */
  static async loadProgress(userId: string, organizationId: string, wizardType: string): Promise<WizardProgress | null> {
    try {
      // If in fallback mode, load from local storage immediately
      if (this.fallbackMode) {
        return this.loadFromLocalStorage(userId, organizationId, wizardType);
      }

      // Try database load first
      try {
        const { data, error } = await supabase
          .from('wizard_progress')
          .select('*')
          .eq('user_id', userId)
          .eq('organization_id', organizationId)
          .eq('wizard_type', wizardType)
          .order('last_active_at', { ascending: false })
          .limit(1)
          .single();

        if (error) {
          // Handle 406 Not Acceptable error
          if (error.message?.includes('406') || error.status === 406) {
            console.warn('üîÑ Database RLS issue on load (406), switching to local storage fallback');
            this.fallbackMode = true;
            return this.loadFromLocalStorage(userId, organizationId, wizardType);
          }

          if (error.code === 'PGRST116') {
            // No progress found in database, check local storage
            return this.loadFromLocalStorage(userId, organizationId, wizardType);
          }
          console.error('Error loading wizard progress:', error);
          return this.loadFromLocalStorage(userId, organizationId, wizardType);
        }

        // Update last active time in database
        try {
          await supabase
            .from('wizard_progress')
            .update({ last_active_at: new Date().toISOString() })
            .eq('id', data.id);
        } catch (updateError) {
          console.warn('Failed to update last active time:', updateError);
        }

        console.log('‚úÖ Loaded wizard progress from database');
        return data;

      } catch (dbError) {
        console.warn('Database load failed, trying local storage:', dbError);
        return this.loadFromLocalStorage(userId, organizationId, wizardType);
      }

    } catch (error) {
      console.error('‚ùå Failed to load wizard progress:', error);
      return this.loadFromLocalStorage(userId, organizationId, wizardType);
    }
  }

  /**
   * Create completion reminder task (skip if in fallback mode)
   */
  private static async manageReminderTask(progress: WizardProgress): Promise<void> {
    try {
      // Skip task creation if in fallback mode
      if (this.fallbackMode) {
        console.log('‚è≠Ô∏è Skipping reminder task creation (fallback mode)');
        return;
      }

      // Don't create task if wizard is completed
      if (progress.progress_percentage >= 100) {
        // Cancel existing reminder if wizard is completed
        if (progress.reminder_task_id) {
          await this.cancelTask(progress.reminder_task_id);
        }
        return;
      }

      // Calculate due date (24 hours from now)
      const dueDate = new Date(Date.now() + 24 * 60 * 60 * 1000);

      const taskData: Omit<ProgressTask, 'id' | 'created_at'> = {
        user_id: progress.user_id,
        organization_id: progress.organization_id,
        title: `Complete ${progress.wizard_type} wizard`,
        description: `You have an incomplete ${progress.wizard_type} wizard at step ${progress.current_step + 1} of ${progress.total_steps}. Please complete it to avoid losing progress.`,
        priority: 'medium',
        due_date: dueDate.toISOString(),
        status: 'pending',
        task_type: 'wizard_completion',
        related_entity_type: 'wizard_progress',
        related_entity_id: progress.id!,
        metadata: {
          wizard_type: progress.wizard_type,
          current_step: progress.current_step,
          total_steps: progress.total_steps,
          progress_percentage: progress.progress_percentage,
          last_saved_at: progress.last_saved_at
        }
      };

      if (progress.reminder_task_id) {
        // Update existing task
        await supabase
          .from('tasks')
          .update(taskData)
          .eq('id', progress.reminder_task_id);
      } else {
        // Create new task
        const { data: newTask, error } = await supabase
          .from('tasks')
          .insert([taskData])
          .select()
          .single();

        if (error) {
          console.error('Error creating reminder task:', error);
          return;
        }

        // Update progress with task ID
        await supabase
          .from('wizard_progress')
          .update({ reminder_task_id: newTask.id })
          .eq('id', progress.id!);
      }

      console.log('‚úÖ Reminder task created/updated for wizard completion');
    } catch (error) {
      console.error('‚ùå Failed to create reminder task:', error);
    }
  }

  /**
   * Cancel reminder task
   */
  private static async cancelTask(taskId: string): Promise<void> {
    try {
      await supabase
        .from('tasks')
        .update({ 
          status: 'cancelled',
          updated_at: new Date().toISOString()
        })
        .eq('id', taskId);
    } catch (error) {
      console.error('Error cancelling task:', error);
    }
  }

  /**
   * Mark wizard as completed
   */
  static async markCompleted(progressId: string, finalData: any): Promise<void> {
    try {
      const { data: progress } = await supabase
        .from('wizard_progress')
        .select('reminder_task_id')
        .eq('id', progressId)
        .single();

      // Update progress to completed
      await supabase
        .from('wizard_progress')
        .update({
          progress_percentage: 100,
          wizard_data: finalData,
          last_saved_at: new Date().toISOString(),
          last_active_at: new Date().toISOString()
        })
        .eq('id', progressId);

      // Cancel reminder task
      if (progress?.reminder_task_id) {
        await this.cancelTask(progress.reminder_task_id);
      }

      console.log('‚úÖ Wizard marked as completed');
    } catch (error) {
      console.error('‚ùå Failed to mark wizard as completed:', error);
    }
  }

  /**
   * Delete wizard progress (when user cancels or explicitly deletes)
   */
  static async deleteProgress(progressId: string): Promise<void> {
    try {
      const { data: progress } = await supabase
        .from('wizard_progress')
        .select('reminder_task_id')
        .eq('id', progressId)
        .single();

      // Cancel reminder task
      if (progress?.reminder_task_id) {
        await this.cancelTask(progress.reminder_task_id);
      }

      // Delete progress
      await supabase
        .from('wizard_progress')
        .delete()
        .eq('id', progressId);

      console.log('‚úÖ Wizard progress deleted');
    } catch (error) {
      console.error('‚ùå Failed to delete wizard progress:', error);
    }
  }

  /**
   * Get all incomplete wizards for a user
   */
  static async getIncompleteWizards(userId: string, organizationId: string): Promise<WizardProgress[]> {
    try {
      const { data, error } = await supabase
        .from('wizard_progress')
        .select('*')
        .eq('user_id', userId)
        .eq('organization_id', organizationId)
        .lt('progress_percentage', 100)
        .order('last_active_at', { ascending: false });

      if (error) {
        console.error('Error loading incomplete wizards:', error);
        return [];
      }

      return data || [];
    } catch (error) {
      console.error('‚ùå Failed to load incomplete wizards:', error);
      return [];
    }
  }

  /**
   * Cleanup expired progress entries
   */
  static async cleanupExpiredProgress(): Promise<void> {
    try {
      // Skip database cleanup if in fallback mode
      if (this.fallbackMode) {
        this.cleanupLocalStorage();
        return;
      }

      const now = new Date().toISOString();
      
      // Get expired progress entries with reminder tasks
      const { data: expiredProgress } = await supabase
        .from('wizard_progress')
        .select('id, reminder_task_id')
        .lt('expires_at', now);

      // Cancel reminder tasks for expired progress
      if (expiredProgress) {
        for (const progress of expiredProgress) {
          if (progress.reminder_task_id) {
            await this.cancelTask(progress.reminder_task_id);
          }
        }
      }

      // Delete expired progress
      await supabase
        .from('wizard_progress')
        .delete()
        .lt('expires_at', now);

      console.log('‚úÖ Cleaned up expired wizard progress');
    } catch (error) {
      console.error('‚ùå Failed to cleanup expired progress:', error);
    }
  }

  /**
   * Clean up expired local storage entries
   */
  private static cleanupLocalStorage(): void {
    try {
      const existingDataStr = localStorage.getItem(this.LOCAL_STORAGE_KEY);
      if (!existingDataStr) return;

      const existingData: WizardProgress[] = JSON.parse(existingDataStr);
      const now = new Date().toISOString();
      
      const validData = existingData.filter(p => p.expires_at > now);
      
      localStorage.setItem(this.LOCAL_STORAGE_KEY, JSON.stringify(validData));
      console.log('‚úÖ Cleaned up expired local storage progress');
    } catch (error) {
      console.error('‚ùå Failed to cleanup local storage:', error);
    }
  }

  /**
   * Attempt to sync local storage data back to database
   */
  static async syncLocalStorageToDatabase(): Promise<boolean> {
    try {
      if (!this.fallbackMode) {
        return true; // Already using database
      }

      // Test if database is working again
      const testResult = await this.testDatabaseConnection();
      if (!testResult) {
        return false;
      }

      // Get local storage data
      const existingDataStr = localStorage.getItem(this.LOCAL_STORAGE_KEY);
      if (!existingDataStr) {
        this.fallbackMode = false;
        return true;
      }

      const localData: WizardProgress[] = JSON.parse(existingDataStr);
      let syncSuccessful = true;

      // Try to sync each progress entry
      for (const progress of localData) {
        try {
          await supabase
            .from('wizard_progress')
            .upsert([{
              user_id: progress.user_id,
              organization_id: progress.organization_id,
              wizard_type: progress.wizard_type,
              current_step: progress.current_step,
              total_steps: progress.total_steps,
              progress_percentage: progress.progress_percentage,
              wizard_data: progress.wizard_data,
              step_statuses: progress.step_statuses,
              last_saved_at: progress.last_saved_at,
              last_active_at: new Date().toISOString(),
              expires_at: progress.expires_at
            }]);
        } catch (syncError) {
          console.warn('Failed to sync progress:', progress.id, syncError);
          syncSuccessful = false;
        }
      }

      if (syncSuccessful) {
        // Clear local storage if sync was successful
        localStorage.removeItem(this.LOCAL_STORAGE_KEY);
        this.fallbackMode = false;
        console.log('‚úÖ Successfully synced local storage to database');
      }

      return syncSuccessful;
    } catch (error) {
      console.error('‚ùå Failed to sync local storage to database:', error);
      return false;
    }
  }

  /**
   * Test if database connection is working
   */
  private static async testDatabaseConnection(): Promise<boolean> {
    try {
      const { error } = await supabase
        .from('wizard_progress')
        .select('id')
        .limit(1);

      return !error || error.code === 'PGRST116'; // No results is OK
    } catch (error) {
      return false;
    }
  }

  /**
   * Check database status and attempt sync if needed
   */
  static async checkAndSync(): Promise<void> {
    if (this.fallbackMode) {
      const synced = await this.syncLocalStorageToDatabase();
      if (synced) {
        console.log('üîÑ Database connection restored, synced local data');
      }
    }
  }
}