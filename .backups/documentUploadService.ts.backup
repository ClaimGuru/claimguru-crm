/**
 * Document Upload Service - FIXED VERSION
 * 
 * Handles document upload to Supabase storage using proper client
 */

import { supabase } from '../lib/supabase'

export interface UploadedDocument {
  id: string
  fileName: string
  filePath: string
  fileSize: number
  mimeType: string
  uploadedAt: string
  publicUrl: string
  documentType: 'policy' | 'claim' | 'estimate' | 'photo' | 'other'
  extractionStatus: 'pending' | 'processing' | 'completed' | 'failed'
  extractedData?: any
}

class DocumentUploadService {
  constructor() {
    console.log('DocumentUploadService initialized with proper Supabase client')
  }

  /**
   * Upload document to Supabase storage using proper client
   */
  async uploadDocument(
    file: File, 
    documentType: UploadedDocument['documentType'] = 'other',
    claimId?: string
  ): Promise<UploadedDocument> {
    try {
      console.log('üöÄ Starting document upload with proper Supabase client')
      
      // Generate unique filename with user context
      const timestamp = Date.now()
      const cleanFileName = file.name.replace(/[^a-zA-Z0-9.-]/g, '_')
      const fileName = `${timestamp}_${cleanFileName}`
      
      // Use document type as folder structure
      const bucketName = 'policy-documents'
      const filePath = `${documentType}s/${fileName}`

      console.log(`üìÅ Uploading: ${file.name} ‚Üí ${bucketName}/${filePath}`)
      console.log(`üìä File details: ${file.size} bytes, ${file.type}`)

      // Upload using proper Supabase storage client
      const { data: uploadData, error: uploadError } = await supabase.storage
        .from(bucketName)
        .upload(filePath, file, {
          cacheControl: '3600',
          upsert: false
        })

      if (uploadError) {
        console.error('‚ùå Supabase storage upload error:', uploadError)
        throw new Error(`Supabase upload failed: ${uploadError.message}`)
      }

      console.log('‚úÖ File uploaded to storage:', uploadData.path)

      // Get public URL using proper Supabase method
      const { data: publicUrlData } = supabase.storage
        .from(bucketName)
        .getPublicUrl(filePath)

      const publicUrl = publicUrlData.publicUrl

      console.log('üåê Public URL generated:', publicUrl)

      // Create document record
      const document: UploadedDocument = {
        id: `doc_${timestamp}`,
        fileName: file.name,
        filePath: uploadData.path,
        fileSize: file.size,
        mimeType: file.type,
        uploadedAt: new Date().toISOString(),
        publicUrl,
        documentType,
        extractionStatus: 'pending'
      }

      // Store document metadata in database
      await this.storeDocumentMetadata(document, claimId)

      console.log('‚úÖ Document upload completed:', document.fileName)
      return document

    } catch (error) {
      console.error('‚ùå Document upload failed:', error)
      throw error
    }
  }

  /**
   * Store document metadata in database using proper Supabase client
   */
  private async storeDocumentMetadata(document: UploadedDocument, claimId?: string): Promise<void> {
    try {
      console.log('üíæ Storing document metadata in database')
      
      const documentData = {
        id: document.id,
        file_name: document.fileName,
        file_path: document.filePath,
        file_size: document.fileSize,
        mime_type: document.mimeType,
        uploaded_at: document.uploadedAt,
        public_url: document.publicUrl,
        document_type: document.documentType,
        extraction_status: document.extractionStatus,
        claim_id: claimId,
        created_at: new Date().toISOString()
      }

      // Use proper Supabase client for database operations
      const { error } = await supabase
        .from('documents')
        .insert(documentData)

      if (error) {
        console.warn('‚ö†Ô∏è Failed to store document metadata:', error.message)
        // Don't throw error - document is still uploaded to storage
      } else {
        console.log('‚úÖ Document metadata stored successfully')
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Failed to store document metadata:', error)
      // Don't throw error - document is still uploaded to storage
    }
  }

  /**
   * Update document extraction status using proper Supabase client
   */
  async updateExtractionStatus(
    documentId: string, 
    status: UploadedDocument['extractionStatus'],
    extractedData?: any
  ): Promise<void> {
    try {
      console.log(`üîÑ Updating extraction status for ${documentId}: ${status}`)
      
      const updateData: any = {
        extraction_status: status,
        updated_at: new Date().toISOString()
      }

      if (extractedData) {
        updateData.extracted_data = extractedData
      }

      // Use proper Supabase client for database updates
      const { error } = await supabase
        .from('documents')
        .update(updateData)
        .eq('id', documentId)

      if (error) {
        console.warn('‚ö†Ô∏è Failed to update extraction status:', error.message)
      } else {
        console.log('‚úÖ Extraction status updated successfully')
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Failed to update extraction status:', error)
    }
  }

  /**
   * Get documents for a claim
   */
  async getClaimDocuments(claimId: string): Promise<UploadedDocument[]> {
    try {
      console.log(`üìÑ Fetching documents for claim: ${claimId}`)
      
      // Use proper Supabase client for database queries
      const { data, error } = await supabase
        .from('documents')
        .select('*')
        .eq('claim_id', claimId)
        .order('created_at', { ascending: false })

      if (error) {
        console.error('‚ö†Ô∏è Failed to fetch claim documents:', error.message)
        return []
      }

      console.log(`‚úÖ Found ${data?.length || 0} documents for claim ${claimId}`)
      return data ? data.map(this.mapDocumentFromDB) : []
    } catch (error) {
      console.error('‚ö†Ô∏è Failed to fetch claim documents:', error)
      return []
    }
  }

  /**
   * Get recent documents using proper Supabase client
   */
  async getRecentDocuments(limit: number = 20): Promise<UploadedDocument[]> {
    try {
      console.log(`üìÑ Fetching recent documents (limit: ${limit})`)
      
      // Use proper Supabase client for database queries
      const { data, error } = await supabase
        .from('documents')
        .select('*')
        .order('uploaded_at', { ascending: false })
        .limit(limit)

      if (error) {
        console.error('‚ö†Ô∏è Failed to fetch recent documents:', error.message)
        return []
      }

      console.log(`‚úÖ Found ${data?.length || 0} recent documents`)
      return data ? data.map(this.mapDocumentFromDB) : []
    } catch (error) {
      console.error('‚ö†Ô∏è Failed to fetch recent documents:', error)
      return []
    }
  }

  /**
   * Delete document using proper Supabase client
   */
  async deleteDocument(documentId: string): Promise<boolean> {
    try {
      console.log(`üóëÔ∏è Deleting document: ${documentId}`)
      
      // Get document info first using Supabase client
      const { data: documents, error: fetchError } = await supabase
        .from('documents')
        .select('file_path')
        .eq('id', documentId)

      if (fetchError) {
        console.error('‚ö†Ô∏è Failed to fetch document info:', fetchError.message)
        return false
      }

      if (!documents || documents.length === 0) {
        console.warn('‚ö†Ô∏è Document not found')
        return false
      }

      const filePath = documents[0].file_path

      // Delete from storage using Supabase client
      const { error: storageError } = await supabase.storage
        .from('policy-documents')
        .remove([filePath])

      if (storageError) {
        console.warn('‚ö†Ô∏è Failed to delete from storage:', storageError.message)
      }

      // Delete from database using Supabase client
      const { error: dbError } = await supabase
        .from('documents')
        .delete()
        .eq('id', documentId)

      if (dbError) {
        console.error('‚ö†Ô∏è Failed to delete from database:', dbError.message)
        return false
      }

      console.log('‚úÖ Document deleted successfully')
      return true
    } catch (error) {
      console.error('‚ö†Ô∏è Failed to delete document:', error)
      return false
    }
  }

  /**
   * Map document from database format
   */
  private mapDocumentFromDB(dbDoc: any): UploadedDocument {
    return {
      id: dbDoc.id,
      fileName: dbDoc.file_name,
      filePath: dbDoc.file_path,
      fileSize: dbDoc.file_size,
      mimeType: dbDoc.mime_type,
      uploadedAt: dbDoc.uploaded_at,
      publicUrl: dbDoc.public_url,
      documentType: dbDoc.document_type,
      extractionStatus: dbDoc.extraction_status,
      extractedData: dbDoc.extracted_data
    }
  }

  /**
   * Process document with AI extraction
   */
  async processDocumentWithAI(document: UploadedDocument, documentType: string): Promise<any> {
    try {
      // Update status to processing
      await this.updateExtractionStatus(document.id, 'processing')

      // Create a File object from the public URL
      const response = await fetch(document.publicUrl)
      const blob = await response.blob()
      const file = new File([blob], document.fileName, { type: document.mimeType })

      // Call the processing edge function
      const formData = new FormData()
      formData.append('file', file)
      formData.append('documentType', documentType)

      const processResponse = await fetch(
        `${this.supabaseUrl}/functions/v1/process-policy-document`,
        {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${this.supabaseKey}`,
          },
          body: formData
        }
      )

      if (processResponse.ok) {
        const result = await processResponse.json()
        
        // Update status to completed with extracted data
        await this.updateExtractionStatus(document.id, 'completed', result.data)
        
        return result.data
      } else {
        // Update status to failed
        await this.updateExtractionStatus(document.id, 'failed')
        throw new Error('Document processing failed')
      }
    } catch (error) {
      console.error('AI processing failed:', error)
      await this.updateExtractionStatus(document.id, 'failed')
      throw error
    }
  }
}

export const documentUploadService = new DocumentUploadService()
